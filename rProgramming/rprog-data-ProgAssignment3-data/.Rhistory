swirl()
library("swirl")
swirl()
1Ç20
1:20
pi:10
15:1
?":"
seq(1, 20)
seq(0, 10, by=0.5)
my_seq <- seq(5, 10, length=30)
length(my_seq)
1:length(my_seq)
seq(along.with = my_seq)
seq_along(my_seq)
rep(0, times = 40)
rep(c(0,1,2), times = 10)
rep(c(0,1,2), each = 10)
0
bye()
swirl()
x <- list(2, "a", "b", TRUE)
x[[2]]
x <- 1:4
y <- 2:3
x + y
x <- 4L
x <- c(1,3, 5)
y <- c(3, 2, 10)
rbind(x, y)
z <- rbind(x, y)
z
View(z)
x <- 1:4
y <- 2
x + y
help.start()
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
cachemean(10)
cachemean(1:10)
makeVector(1:10)
# I found an easy test script from the discussion forum of coursea.
# https://class.coursera.org/rprog-005/forum/thread?thread_id=140
# Cheers!
# This function creates a special "matrix" object
# that can cache its inverse.
makeCacheMatrix <- function ( x = matrix() ) {
# We cache the inverse of matrix "x"
# in the variable "inverse".
# When there's no matrix, it's supposed to be "NULL".
inverse <- NULL;
# It's a set function,
# meaning that we can set a specific matrix
# to the instance of this class of "matrix".
set <- function(y) {
x <<- y;
inverse <<- NULL;
}
# Get the matrix.
get <- function() {
x;
}
# We can directly set the inverse of the matrix.
setinverse <- function(inv) {
inverse <<- inv;
}
# We can get the inverse of the matrix.
getinverse <- function() {
inverse;
}
# Actually "makeCacheMatrix" is a list,
# or an object, or a class.
# After we instantiate the class,
# we'll get a instance with its methods.
list(	set = set,
get = get,
setinverse = setinverse,
getinverse = getinverse
)
}
# This function computes the inverse of the special "matrix"
# returned by makeCacheMatrix above.
# If the inverse has already been calculated
# (and the matrix has not changed),
# then the cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
# Here we receive the parameter "x"
# as a instance of "makeCacheMatrix".
# We first check the value of inverse.
inverse <- x$getinverse();
if( !is.null(inverse) ) {
message("getting chached data");
}
else {
data <- x$get();
inverse <- x$setinverse(solve(data));
}
inverse;
## Return a matrix that is the inverse of 'x'
}
makeCacheMatrix(1Ç4)
makeCacheMatrix(1:4)
matrix <- makeCacheMatrix(1:4)
matrix
vector <- makeVector(1Ç4)
vector <- makeVector(1:4)
vector
makeVector$getmean
:vector
?vector
as.vector(data.frame(x = 1:3, y = 5:7), mode = "numeric")
data.frame(x = 1:3, y = 5:7)
(as.vector(data.frame(x = 1:3, y = 5:7), mode = "numeric"))
x <- c(a = 1, b = 2)
is.vector(x)
x
x <- c(a = 1, b = 2, c = 3)
is.vector(x)
x
makeVector(x = x)
help.start()
map("worldHires","Spain")
library(xlsx)
library(ggmap)
library(mapdata)
library(ggplot2)
set.seed(1)
rnorm(5)
set.seed(1)
rnorm(5)
outcome <- "pneumonia"
num = "worst"
setwd("C:/Users/Carol e Le/Desktop/coursera/rProgramming/rprog-data-ProgAssignment3-data")
data_dir <- getwd()
data <- read.csv("outcome-of-care-measures.csv", colClasses = "character", header = TRUE, na.strings="Not Available")
uniqueState <- unique( data[, "State"] )
if (outcome != "heart attack" && outcome != "heart failure" && outcome != "pneumonia") {
stop("invalid outcome")
}
subData <- (subset(x = data, select = c(2, 7, 11, 17, 23)))
colnames(subData)<- c("hospital name","State","heart attack","heart failure","pneumonia")
subData <- subset(subData, select = c("hospital name", "State", outcome))
subData <- na.omit(subData)
subData
subData[order(as.double(subData[,3]),subData[,1]),]
lapply(subData$State, max(subData$State))
outcome
head(lapply(subData$State, max(subData$State)))
lapply(subData$State, max(subData$State))
head(subData[order(as.double(subData[,3]),subData[,1]),])
lapply(subData$State, max(subData$outcome))
max(subData$outcome)
max(subData)
?max
lapply(subData$State, max(subData$outcome))
lapply(subData$State, max)
lapply(subData$outcome, max)
list(lapply(subData$outcome, max))
lapply(subData$outcome, max)
maximo <- lapply(subData$outcome, max)
maximo
maximo <- lapply(subData$outcome, max(subData$State))
maximo <- lapply(subData$outcome, max)
maximo <- sapply(subData$outcome, max)
maximo <- sapply(subData$state, max)
maximo <- sapply(subData$State, max)
maximo
maximo <- sapply(subData$outcome, max)
maximo
for( i in uniqueState$first:uniqueState$last ){
i
}
for( i in uniqueState.first:uniqueState.last ){
i
}
for( i in uniqueState ){
i
}
for( i in uniqueState ){
print(i)
}
subData[order(which(as.double(subData[,3]),subData[,1]) == i),]
order(as.double(subData[,3]),subData[,1])
subData[order(as.double(subData[,3]),subData[,1]),]
subData[which(subData$State == i),]
i <- "AL"
subData[which(subData$State == i),]
subData[order(as.double(which(subData$State == i)[,3]), subData[1]),]
subData[order(as.double(which(subData$State == i)), subData[1]),]
subData[order(as.double(which(subData$State == i)),]
subData[order(as.double(which(subData$State == i))),]
subData[which(subData$State == i),]
order(subData[which(subData$State == i),])
order(subData[which(subData$State == i),])
subData[which(subData$State == i),]
dataState <- subData[which(subData$State == i),]
orderedState <- dataState[order(as.double(dataState[,3]),dataState[,1]),]
orderedState
orderedData <- data.frame()
for( i in uniqueState ){
dataState <- subData[which(subData$State == i),]
orderedState <- dataState[order(as.double(dataState[,3]),dataState[,1]),]
orderedData <- rbind(orderedData, orderedState)
}
orderedData
remove(orderedData)
rankedData <- data.frame()
for( i in uniqueState ){
dataState <- subData[which(subData$State == i),]
orderedState <- dataState[order(as.double(dataState[,3]),dataState[,1]),]
rankedState <- cbind(orderedState, c(1:nrow(x = orderedState)))
orderedData <- rbind(orderedData, rankedState)
}
for( i in uniqueState ){
dataState <- subData[which(subData$State == i),]
orderedState <- dataState[order(as.double(dataState[,3]),dataState[,1]),]
rankedState <- cbind(orderedState, c(1:nrow(x = orderedState)))
rankedData <- rbind(rankedData, rankedState)
}
rankedData
rankedData
nrow(rankedData[which(rankedData$State == i),])
rbind( returnData, as.character(subset(returnData, returnData[,"rank"] == num)))
returnData <- data.frame()
rbind( returnData, as.character(subset(returnData, returnData[,"rank"] == num)))
colnames(returnData) <- names(rankedData)
names(rankedData)
colnames(returnData) <- names(rankedData)
rbind( returnData, as.character(subset(rankedData, rankedData[,"rank"] == num)))
colnames(rankedData)[4] <- "rank"
rbind( returnData, as.character(subset(rankedData, rankedData[,"rank"] == num)))
num
if (num == "best"){
num <- 1
} else if (num == "worst"){
num <- nrow(rankedData[which(rankedData$State == i),])
}
num
rbind( returnData, as.character(subset(rankedData, rankedData[,"rank"] == num)))
as.character(subset(rankedData, rankedData[,"rank"] == num))
subset(rankedData, rankedData[, "State"] == i)
subset( subset(rankedData, rankedData[, "State"] == i), rankedData[, "rank"] == num )
subset( rankedData[, "rank"] == num )
subset( rankedData, rankedData[, "rank"] == num )
subset( subset( rankedData, rankedData[, "rank"] == num ), rankedData[, "State"] == i )
i
subset( subset( rankedData, rankedData[, "rank"] == num ), rankedData[, "State"] == i )
subset( subset( rankedData, rankedData[, "rank"] == num ), rankedData[, "State"] == i )
subset( rankedData, rankedData[, "rank"] == num )
subset( rankedData, rankedData[, "rank"] == num && rankedData[, "State"] == i ) )
subset( rankedData, (rankedData[, "rank"] == num && rankedData[, "State"] == i) ) )
subset( rankedData, (rankedData[, "rank"] == num) ) )
subset( rankedData, rankedData[, "rank"] == num ) )
subset( rankedData, rankedData[, "rank"] == num )
subset( rankedData, (rankedData[, "rank"] == num && rankedData[, "State"] == i) )
subset( rankedData, rankedData[, "rank"] == num && rankedData[, "State"] == i )
subset( rankedData, rankedData[, "rank"] == num & rankedData[, "State"] == i )
rbind( returnData, as.character(subset( rankedData, rankedData[, "rank"] == num & rankedData[, "State"] == i )))
returnData
rbind( returnData, as.character(subset( rankedData, rankedData[, "rank"] == num & rankedData[, "State"] == i )))
num <- "worst"
for( i in uniqueState ){
if (num == "best"){
num2 <- 1
} else if (num == "worst"){
num2 <- nrow(rankedData[which(rankedData$State == i),])
}
returnData <- rbind( returnData, as.character(subset( rankedData, rankedData[, "rank"] == num2 & rankedData[, "State"] == i )))
}
for( i in uniqueState ){
if (num == "best"){
num2 <- 1
} else if (num == "worst"){
num2 <- nrow(rankedData[which(rankedData$State == i),])
}
returnData <- suppressWarnings(rbind( returnData, as.character(subset( rankedData, rankedData[, "rank"] == num2 & rankedData[, "State"] == i ))))
}
returnData
suppressWarnings(rbind( returnData, as.character(subset( rankedData, rankedData[, "rank"] == num2 & rankedData[, "State"] == i ))))
suppressWarnings(rbind( returnData, as.character(subset( rankedData, rankedData[, "rank"] == num2 & rankedData[, "State"] == i ))))
as.character(subset( rankedData, rankedData[, "rank"] == num2 & rankedData[, "State"] == i ))
returnData
remove(returnData)
colnames(rankedData)[4] <- "rank"
returnData <- data.frame()
if (num == "best"){
num2 <- 1
} else if (num == "worst"){
num2 <- nrow(rankedData[which(rankedData$State == i),])
}
num2
returnData <- suppressWarnings(rbind( returnData, as.character(subset( rankedData, rankedData[, "rank"] == num2 & rankedData[, "State"] == i ))))
returnData
remove(returnData)
colnames(rankedData)[4] <- "rank"
returnData <- data.frame()
for( i in uniqueState ){
if (num == "best"){
num2 <- 1
} else if (num == "worst"){
num2 <- nrow(rankedData[which(rankedData$State == i),])
}
returnData <- suppressWarnings(rbind( returnData, as.character(subset( rankedData, rankedData[, "rank"] == num2 & rankedData[, "State"] == i ))))
}
returnData
remove(ReturnData)
remove(returnData)
returnData <- data.frame()
for( i in uniqueState ){
if (num == "best"){
num2 <- 1
} else if (num == "worst"){
num2 <- nrow(rankedData[which(rankedData$State == i),])
}
returnData <- na.omit(suppressWarnings(rbind( returnData, as.character(subset( rankedData, rankedData[, "rank"] == num2 & rankedData[, "State"] == i )))))
}
returnData
num
uniqueState
if (num == "best"){
num2 <- 1
} else if (num == "worst"){
num2 <- nrow(rankedData[which(rankedData$State == i),])
}else{
num2 <- num
}
num
num2
i <- "AK"
num
if (num == "best"){
num2 <- 1
} else if (num == "worst"){
num2 <- nrow(rankedData[which(rankedData$State == i),])
}else{
num2 <- num
}
num2
na.omit(suppressWarnings(rbind( returnData, as.character(subset( rankedData, rankedData[, "rank"] == num2 & rankedData[, "State"] == i )))))
returnData
as.character(subset( rankedData, rankedData[, "rank"] == num2 & rankedData[, "State"] == i ))
rbind( returnData, as.character(subset( rankedData, rankedData[, "rank"] == num2 & rankedData[, "State"] == i ))))
rbind( returnData, as.character(subset( rankedData, rankedData[, "rank"] == num2 & rankedData[, "State"] == i )))
positionData <- as.character(subset( rankedData, rankedData[, "rank"] == num2 & rankedData[, "State"] == i ))
positionData
rbind( returnData, positionData)
colnames(positionData) <- names(rankedData)
positionData
rankedData
positionData
names(rankedData)
names(positionData)
colnames(positionData) <- c(names(rankedData))
c(names(rankedData))
colnames(positionData) <- c(names(rankedData))
colnames(positionData[1:ncol(x = positionData)]) <- c(names(rankedData))
positionData[1:ncol(x = positionData)]
ncol(x = positionData)
?ncol
positionData
names(rankedData)
colnames(positionData) <- c("hospital name", "State", "pneumonia", "rank")
